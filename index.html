<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Paper Lineage</title>
    <meta
      name="description"
      content="Paper Lineage is a visualization tool for finding the lineage of academic papers."
    />
    <link
      rel="preload"
      href="/lineage.json"
      as="fetch"
      crossorigin="anonymous"
    />
    <style>
      :root {
        --ac1-color: steelblue;
        --ac2-color: rgb(164, 202, 254);
        --bg-color: #fff;
        --fg-color: rgb(18, 19, 20);
        --max-content-width: 880px;
      }

      *,
      ::before,
      ::after {
        box-sizing: border-box;
        border-style: solid;
        border-width: 0;
      }

      body {
        color: var(--fg-color);
        background: var(--bg-color);
        font-size: calc(10px + 0.3vw);
        line-height: 1.2;
      }

      a {
        text-decoration: none;
        color: var(--ac1-color);
        position: relative;
        white-space: nowrap;
      }

      nav,
      main {
        position: absolute;
        margin: 0 auto;
        top: 0;
        left: 0;
        right: 0;
        width: 80vw;
      }

      nav {
        font-weight: bold;
        line-height: 2.2;
        font-size: 1.3em;
        padding: 2rem 2.5rem;
        max-width: var(--max-content-width);
        z-index: 100;
      }

      main {
        padding: 6em 2.5rem;
        background-color: var(--bg-color);
        max-width: var(--max-content-width);
        min-height: 90vh;
      }

      ul {
        list-style-type: none;
        padding-left: 0;
        margin: 0;
      }

      input {
        width: 100%;
        padding: 0.5rem 1rem;
        border: 1px solid var(--ac1-color);
        border-radius: 0.3rem;
        font-size: inherit;
      }

      input:focus {
        outline: none;
        border-color: transparent;
        box-shadow: 0 0 2pt 2pt orange;
      }

      .searchArea {
        position: absolute;
        z-index: 10;
        width: 100%;
        padding: 0;
        overflow-y: scroll;
        border: 1px var(--ac2-color);
        border-style: solid;
        border-radius: 0.3rem;
        text-align: right;
      }

      .searchItem {
        cursor: pointer;
        padding: 0.5rem;
        border-style: solid;
        border-top-width: 1px;
        border-color: var(--ac2-color);
        background-color: var(--bg-color);
      }

      .searchItem:hover,
      .searchItem:focus {
        background-color: rgb(229, 231, 235);
      }
    </style>
  </head>

  <body>
    <nav>
      <a href="/">Home</a>
      /
      <a href="https://github.com/belinghy/paper-lineage">About</a>
      /
    </nav>
    <main id="home">
      <div id="searchBox" style="position: relative; width: 100%">
        <input
          id="searchBar"
          autocomplete="off"
          spellcheck="false"
          placeholder="Search for a paper"
        />
      </div>
      <div id="svgContainer"></div>
    </main>

    <!-- load the d3.js library -->
    <script src="/assets/d3.min.js"></script>
    <!-- Fuzzy search -->
    <script src="/assets/fuse.min.js"></script>

    <script>
      (async () => {
        const pubData = await fetch("/lineage.json").then((response) => {
          return response.json();
        });

        const fuse = new Fuse(pubData, {
          // includeScore: true,
          minMatchCharLength: 3,
          keys: ["title"],
        });

        function drawAndSetHistory(tree, replace = false) {
          drawTree(tree);
          const url = new URL(window.location);
          url.searchParams.set("title", tree.title);
          document.title = `Paper Lineage | ${tree.title}`;
          window.history[replace ? "replaceState" : "pushState"](tree, "", url);
        }

        // Load a random tree by default, unless url has search parameter
        const params = new URLSearchParams(window.location.search);
        const title = params.get("title");
        const tree = title
          ? fuse.search(title)[0].item
          : pubData[Math.floor(Math.random() * pubData.length)];
        drawAndSetHistory(tree, true);

        window.addEventListener(
          "popstate",
          function (event) {
            const tree =
              event.state ||
              pubData[Math.floor(Math.random() * pubData.length)];
            drawTree(tree);
            document.title = `Paper Lineage | ${tree.title}`;
          },
          false
        );

        const searchBox = document.getElementById("searchBox");
        const searchBar = document.getElementById("searchBar");

        searchBar.addEventListener("keyup", search);
        searchBar.addEventListener("click", search);
        document.addEventListener("click", function (event) {
          if (!searchBox.contains(event.target)) {
            removeSearchArea();
          }
        });

        document.addEventListener("keydown", function (event) {
          // listen to keyboard events
          if (searchBox.contains(event.target)) {
            let list = searchBar.parentNode.lastChild.firstChild; // targets the <ul>
            let first = list ? list.firstChild : searchBar;
            let last = list ? list.lastChild : searchBar;
            switch (event.code) {
              case "ArrowUp":
                event.preventDefault();
                if (document.activeElement == (searchBar || first)) {
                  break;
                } else {
                  let prev = document.activeElement.previousSibling;
                  prev && prev.focus ? prev.focus() : last.focus();
                }
                break;
              case "ArrowDown":
                event.preventDefault();
                if (document.activeElement == searchBar) {
                  first.focus();
                } else {
                  let next = document.activeElement.nextSibling;
                  next && next.focus ? next.focus() : first.focus();
                }
                break;
              case "Enter":
                document.activeElement.onmousedown();
                break;
            }
          }
        });

        // ************** Generate the tree diagram	*****************
        function drawTree(root) {
          const svgContainer = document.getElementById("svgContainer");

          // Delete old tree
          window.svgContainer = svgContainer;
          for (let i = 0; i < svgContainer.children.length; i++) {
            if (svgContainer.children[i].tagName == "svg") {
              svgContainer.children[i].remove();
            }
          }

          const BWIDTH = 800;
          const BHEIGHT = 600;
          const DURATION = 750;

          const margin = { top: 20, right: 120, bottom: 80, left: 120 };
          const width = BWIDTH - margin.right - margin.left;
          const height = BHEIGHT - margin.top - margin.bottom;

          let tree = d3.layout.tree().size([height, width]);

          let diagonal = function link(d) {
            return (
              `M${d.source.y},${d.source.x}` +
              `C${(d.source.y + d.target.y) / 2},${d.source.x} ` +
              `${(d.source.y + d.target.y) / 2},${d.target.x} ` +
              `${d.target.y},${d.target.x}`
            );
          };

          let svg = d3
            .select("#svgContainer")
            .append("svg")
            .attr("preserveAspectRatio", "xMinYMin meet")
            .attr("viewBox", `0 0 ${BWIDTH} ${BHEIGHT}`)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

          root.x0 = height / 2;
          root.y0 = 0;

          update(root);

          function update(source) {
            // Compute the new tree layout.
            let nodes = tree.nodes(root).reverse();
            let links = tree.links(nodes);

            // Normalize for fixed-depth.
            nodes.forEach((d) => (d.y = d.depth * 180));

            // Update the nodes…
            let node = (() => {
              let i = 0;
              return svg
                .selectAll("g.node")
                .data(nodes, (d) => d.id || (d.id = ++i));
            })();

            // Enter any new nodes at the parent's previous position.
            let nodeEnter = node
              .enter()
              .append("g")
              .attr("class", "node")
              .attr("cursor", "pointer")
              .attr("transform", (d) => `translate(${source.y0},${source.x0})`)
              .on("click", (d) => (d.link ? (window.location = d.link) : null));

            nodeEnter
              .append("circle")
              .attr("r", 1e-6)
              .attr("fill", "#fff")
              .attr("stroke", "steelblue")
              .attr("stroke-width", 3);

            nodeEnter
              .append("text")
              .attr("x", 0)
              .attr("y", "2.5em")
              .attr("text-anchor", "middle")
              .attr("font-family", "sans-serif")
              .attr("font-size", "13.5px")
              .text(function (d) {
                const more = d.description ? ` \n (${d.description})` : "";
                return `${d.title}${more}`;
              })
              .call(wrap, 160);

            nodeEnter.attr("transform", (d) => `translate(${d.y},${d.x})`);

            let nodeUpdate = node
              .select("circle")
              .transition()
              .duration(DURATION)
              .attr("r", 10);

            // Update the links…
            let link = svg
              .selectAll("path.link")
              .data(links, (d) => d.target.id);

            // Enter any new links at the parent's previous position.
            link
              .enter()
              .insert("path", "g")
              .attr("class", "link")
              .attr("stroke", "#ccc")
              .attr("fill", "none")
              .attr("stroke-width", "2px")
              .attr("d", diagonal);
          }

          function wrap(text, width) {
            text.each(function () {
              let text = d3.select(this),
                words = text.text().split(" ").reverse(),
                word,
                line = [],
                lineNumber = 0,
                lineHeight = 1.1, // ems
                x = text.attr("x"),
                y = text.attr("y"),
                dy = 0, //parseFloat(text.attr("dy")),
                tspan = text
                  .text(null)
                  .append("tspan")
                  .attr("x", x)
                  .attr("y", y)
                  .attr("dy", dy + "em");
              while ((word = words.pop())) {
                line.push(word);
                tspan.text(line.join(" "));
                if (
                  tspan.node().getComputedTextLength() > width ||
                  word == "\n"
                ) {
                  line.pop();
                  tspan.text(line.join(" "));
                  line = [word];
                  tspan = text
                    .append("tspan")
                    .attr("x", x)
                    .attr("y", y)
                    .attr("dy", ++lineNumber * lineHeight + dy + "em")
                    .text(word);
                }
              }
            });
          }
        }

        function search(event) {
          const searchString = event.target.value;

          removeSearchArea();

          if (searchString.length >= 3) {
            const results = fuse.search(searchString);

            if (results.length > 0) {
              const resultArea = document.createElement("div");
              resultArea.className = "searchArea";

              const resultList = document.createElement("ul");

              const maxItems = Math.min(results.length, 6);
              for (let i = 0; i < maxItems; i++) {
                const resultItem = document.createElement("li");
                resultItem.className = "searchItem";
                resultItem.tabIndex = 0;
                resultItem.onmousedown = function (event) {
                  drawAndSetHistory(results[i].item);
                  removeSearchArea();
                };

                const itemTitle = document.createElement("div");
                itemTitle.innerText = results[i].item.title;

                resultItem.appendChild(itemTitle);
                resultList.appendChild(resultItem);
              }
              resultArea.appendChild(resultList);
              searchBox.appendChild(resultArea);
            }
          }
        }

        function removeSearchArea() {
          let searchAreas = document.getElementsByClassName("searchArea");
          for (const area of searchAreas) {
            area.remove();
          }
        }
      })();
    </script>
  </body>
</html>
